# Установка рабочей директории
setwd('~/kis/lr-1')

# Загрузка датасета
Dataset<-read.csv("Computers.csv",sep=",")
head(Dataset)

# Каждый компьютер - это Wi \in W, где W = Dataset - множество решений

# price, speed, hd, ram - основные конструктивные параметры P1, P2, P3, P4.

# Количество станций каждого сегмента для 8 варианта:
# 5   <= C1 <=  9
# 20  <= C2 <=  32
# 3   <= C3 <=  18
# 5   <= C4 <=  14

# Ограничения на число Ci слева
CL <- c(5, 20, 3,  5)
# Ограничения на число Ci справа
CR <- c(9, 32, 18, 14)

# Регрессионный анализ — набор статистических методов исследования влияния одной или нескольких независимых
# переменных x1, ..., xn на зависимую переменную y. Независимые переменные иначе называют регрессорами или предикторами, 
# а зависимые переменные — критериальными или регрессантами. 
# Терминология зависимых и независимых переменных отражает лишь математическую зависимость переменных (корелляцию), 
# а не причинно-следственные отношения.

# lm() используется для подбора модели линейной регрессии.
lin_model <- lm(price~speed+ram+hd, Dataset)
lin_model
# (Intercept)      speed       ram           hd  
#  1492.1775       5.8112      78.2357      -0.5357  
# price ~ 1492.1775 + 5.8112 * speed + 78.2357 * ram - 0.5357 * hd

# Функция predict() используется для прогнозирования значений на основе входных данных.
g <- predict(lin_model, Dataset)
head(data.frame(Dataset$price, g))

###############################
# Построить двухуровневую задачу проектирования КИС. 
# На верхнем уровне оптимизируется стоимость всей системы в целом. 
# На нижнем уровне по сегментам оптимизируется: 
#   - суммарная производительность (speed, ram) всего серверного оборудования,
#   - суммарный объем долговременной и оперативной памяти (hd, ram). 
# При необходимости провести нормализацию конструктивных параметров.
# Остальные критерии оптимизации, коэффициенты важности выбрать самостоятельно.

# На исходном датафрейме выбрать варианты, удовлетворяющие условиям работоспособности,
# на полученном множестве выбрать Парето-оптимальные решения,
# из множества эффективных по Парето решений подобрать варианты,
# которые наиболее близки к решениям задачи оптимизации.

# Сделать окончательные выводы (i = 1..4):
# Сегмент Ci: количество компьютеров: n_ci, номер компьютера: ID_ci
###############################

###############################
# На верхнем уровне мы предъявляем требования к целевым свойствам системы 
# (общесистемным параметрам): производительности, надежности и т.д. 
# На нижнем уровне требования предъявляются к конструктивным параметрам.
###############################

# 1. Верхний уровень:
# Самостоятельно сформулировать ограничения (максимальные или минимальные) 
# на общую стоимость развертывания всей технической инфраструктуры КИС,
# возможные ограничения на суммарную стоимость отдельных типов станций (C1, C2, C3, C4), 
# нижние ограничения на частоту процессора для станций, другие приемлемые ограничения.

# критерии уровней - это общие критерии, они характеризуются направленностью (минимизация/максимализация)
# частные критерии характеризуют отношение величин к конкретной величине
# критерии могут характеризоваться направленностью или отношением к величине

# Критерий верхнего уровня:
  # H1 = N1 * price1 + ... + N4 * price4 -> min
  # H1 = sum(Ni * (1492.1775 + 5.8112 * speed_i + 78.2357 * ram_i - 0.5357 * hd_i))
  # H1 = 
  # 1492.1775 * N1 + 5.8112 * N1 * speed1 + 78.2357 * N1 * ram1 - 0.5357 * N1 * hd1 +
  # 1492.1775 * N2 + 5.8112 * N2 * speed1 + 78.2357 * N2 * ram1 - 0.5357 * N2 * hd1 +
  # 1492.1775 * N3 + 5.8112 * N3 * speed1 + 78.2357 * N3 * ram1 - 0.5357 * N3 * hd1 +
  # 1492.1775 * N4 + 5.8112 * N4 * speed1 + 78.2357 * N4 * ram1 - 0.5357 * N4 * hd1

# i - номер сегмента (1, 2, 3, 4)
# xi1 = 1492.1775 * Ni
# xi2 = speed_i * Ni
# xi3 = ram_i * Ni
# xi4 = hd_i * Ni

# price_i = 1492.1775 + 5.8112 * speed_i + 78.2357 * ram_i - 0.5357 * hd_i
# price_i * Ni = xi1 + 5.8112 * xi2 + 78.2357 * xi3 - 0.5357 * xi4

# Для нахождения ограничений на xi2, xi3, xi4 можно взять усредненные характеристики:
mean(Dataset$speed) # = 52.0110241252596
mean(Dataset$ram)   # = 8.28694679661288
mean(Dataset$hd)    # = 416.601693561272

# Тогда:

  # ограничения на xij
  # Ci_min * 1492.1775  <= xi1 <= Ci_max * 1492.1775
  # Ci_min * 52.011     <= xi2 <= Ci_max * 52.011
  # Ci_min * 8.287      <= xi3 <= Ci_max * 8.287
  # Ci_min * 416.602    <= xi4 <= Ci_max * 416.602

# Restrictions left
XRL <- matrix(nrow = 4, ncol = 4)
# Restrictions right
XRR <- matrix(nrow = 4, ncol = 4)
for (i in c(1:4)) {
  XRL[i,1]=1492.1775 * CL[i]
  XRL[i,2]=52.011    * CL[i]
  XRL[i,3]=8.287     * CL[i]
  XRL[i,4]=416.602   * CL[i]
  
  XRR[i,1]=1492.1775 * CR[i]
  XRR[i,2]=52.011    * CR[i]
  XRR[i,3]=8.287     * CR[i]
  XRR[i,4]=416.602   * CR[i]
}


# Ограничения нижнего уровня:
  # Cуммарная стоимость компьютеров сегмента C1 должна быть не более 15000 у.е.
    # N1 * price <= 15000
    # x11 + 5.8112 * x12 + 78.2357 * x13 - 0.5357 * x14 <= 15000
  # Cуммарная производительность C1 и C2 не менее 2000
    # N1 * speed1 + N2 * speed2 >= 2000
    # x12 + x22 >= 2000
  # Суммарный объем жесткого диска сегментов C3 и C4 не менее 4000
    # N3 * hd3 + N4 * hd4 >= 4000
    # x34 + x44 >= 4000
  # Cуммарный объем оперативной памяти C3 и C4 не менее 200
    # N3 * ram3 + N4 * ram4 >= 200
    # x33 + x43 >= 200

# Частные критерии оптимизации на нижнем уровне:
  # Cуммарная производительность (speed, ram) в сегменте C1 максимизируется:
    # W1 = 0.7 * N1 * speed1 + 0.3 * N1 * ram1 -> max
    # W1 = 0.7 * x12 + 0.3 * x13 -> max
  # Суммарный объем памяти (ram, hd) в сегменте C3 максимизируется:
    # W2 = 0.3 * N3 * ram3 + 0.8 * N3 * ram3 -> max
    # W2 = 0.3 * x33 + 0.8 * x34 -> max
  # Cуммарная производительность C1 и C2 максимизируется:
    # W3 = 0.9 * N1 * speed1 + 0.9 * N1 * ram1 + 0.4 * N2 * speed2 + 0.4 * N2 * ram2 -> max
    # W3 = 0.9 * x12 + 0.9 * x13 + 0.4 * x22 + 0.4 * x23 -> max

  # Критерий нижнего уровня: 
    # H2 = W1 + 0.8 * W2 + W3 -> max

# Итого:

# Критерий верхнего уровня: 
# H1 = 
#     x11 + 5.8112 * x12 + 78.2357 * x13 - 0.5357 * x14 + 
#     x21 + 5.8112 * x22 + 78.2357 * x23 - 0.5357 * x24 + 
#     x31 + 5.8112 * x32 + 78.2357 * x33 - 0.5357 * x34 + 
#     x41 + 5.8112 * x42 + 78.2357 * x43 - 0.5357 * x44

H1<-function(
    x11,x12,x13,x14, 
    x21,x22,x23,x24, 
    x31,x32,x33,x34, 
    x41,x42,x43,x44
) {
  return(
         x11 + 5.8112 * x12 + 78.2357 * x13 - 0.5357 * x14 + 
         x21 + 5.8112 * x22 + 78.2357 * x23 - 0.5357 * x24 + 
         x31 + 5.8112 * x32 + 78.2357 * x33 - 0.5357 * x34 + 
         x41 + 5.8112 * x42 + 78.2357 * x43 - 0.5357 * x44
  )
}

# Критерий нижнего уровня: 
  # H2 = W1 + 0.8 * W2 + W3 -> max
  # H2 = 0.7 * x12 + 0.3 * x13 + 0.8 * (0.3 * x33 + 0.8 * x34) + 0.9 * x12 + 0.9 * x13 + 0.4 * x22 + 0.4 * x23 -> max
  # H2 = 0.7*x12 + 0.3*x13 + 0.24*x33 + 0.64*x34 + 0.9*x12 + 0.9*x13 + 0.4*x22 + 0.4*x23 -> max
  # H2 = 1.6*x12 + 1.2*x13 + 0.4*x22 + 0.4*x23 + 0.24*x33 + 0.64*x34 -> max

H2<-function(
    x12,x13,x22,x23,x33,x34
) {
  return(1.6*x12 + 1.2*x13 + 0.4*x22 + 0.4*x23 + 0.24*x33 + 0.64*x34)
}

# Как решать:

# Имеем две задачи:
# Минимизировать выражение H1 с учетом ограничений на xij и H2 >= H2(mean(DATA))
# Максимизировать выражение H2 с учетом ограничений на xij и H1 <= H1(mean(DATA))

# Выберем критерий для максимизации, остальные критерии положим в ограничения, 
# задав их значения не менее (для максимизируемых) или не более (для минимизируемых) средних на выборке.

# Эти задачи решаются с помощью библиотеки lpSolve (linear programming solve), 
# предназначенной для решения задач линейного программирования.
# Линейное программирование посвящено решению экстремальных задач на множествах 
# n-мерного векторного пространства, задаваемых системами линейных уравнений и неравенств.
# Для решения ЛР в этой библиотеке используется фукнция lp (https://www.rdocumentation.org/packages/lpSolve/versions/5.6.13/topics/lp)
# Выражения делятся на object (объект оптимизации, в случае ЛР - H1/H2) и subject (ограничения, в случае ЛР - ограничения на xij).

# install.packages("lpSolve")
library(lpSolve)

#############################################
################## РЕШЕНИЕ ################## 
#############################################

# Решаем H1 при условиях H2 -> max и ограничениях на xij

#Вычислим meanH2
##################################
TempDataset <-data.frame(
  Dataset, H2(Dataset$speed, Dataset$ram, Dataset$speed, Dataset$ram, Dataset$ram, Dataset$hd)
)
colnames(TempDataset)<-c("","price","speed","hd","ram","screen","cd", "multi", "premium", "ads","trend","H2")
meanH2<-mean(TempDataset$H2)
##################################

# Numeric vector of coefficients of objective function
objective.in<-c(1, 5.8112, 78.2357, -0.5357, 1, 5.8112, 78.2357, -0.5357, 1,5.8112, 78.2357, -0.5357, 1, 5.8112, 78.2357, -0.5357)

# Matrix of numeric constraint coefficients, one row per constraint, one column per variable.
const.mat<-matrix(c(
# x11 x12 x13 x14 x21 x22 x23 x24 x31 x32 x33 x34 x41 x42 x43 x44
  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,
  # Ограничения нижнего уровня
  1,  5.8112,  78.2357,  -0.5357,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, # x11 + 5.8112 * x12 + 78.2357 * x13 - 0.5357 * x14 <= 15000
  0,  1,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, # x12 + x22 >= 2000
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  1, # x34 + x44 >= 4000
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  1,  0, # x33 + x43 >= 200
  # Критерий нижнего уровня: H2 = 1.6*x12 + 1.2*x13 + 0.4*x22 + 0.4*x23 + 0.24*x33 + 0.64*x34 -> max
  0,    1.6,  1.2,  0,   0,  0.4,  0.4,   0,   0,    0,  0.24, 0.64,  0,   0,   0,   0
# x11   x12   x13  x14  x21  x22   x23   x24  x31   x32   x33   x34   x41  x42  x43  x44
), nrow=32+4+1, byrow=TRUE)

# Vector of character strings giving the direction of the constraint: each value should be one of "<," "<=," "=," "==," ">," or ">=". (In each pair the two values are identical.)
# каждый знак неравенства соответствует строке матрицы
const.dir<-c(
  # Ограничения на xij
  ">=","<=",">=","<=",">=","<=",">=","<=",
  ">=","<=",">=","<=",">=","<=",">=","<=",
  ">=","<=",">=","<=",">=","<=",">=","<=",
  ">=","<=",">=","<=",">=","<=",">=","<=",
  # Ограничения нижнего уровня
  "<=",
  ">=",
  ">=",
  ">=",
  # H2
  ">="
)

const.rhs<-c(
  XRL[1,1],XRR[1,1],XRL[1,2],XRR[1,2],XRL[1,3],XRR[1,3],XRL[1,4],XRR[1,4],
  XRL[2,1],XRR[2,1],XRL[2,2],XRR[2,2],XRL[2,3],XRR[2,3],XRL[2,4],XRR[2,4],
  XRL[3,1],XRR[3,1],XRL[3,2],XRR[3,2],XRL[3,3],XRR[3,3],XRL[3,4],XRR[3,4],
  XRL[4,1],XRR[4,1],XRL[4,2],XRR[4,2],XRL[4,3],XRR[4,3],XRL[4,4],XRR[4,4],
  # Ограничения нижнего уровня
  15000,
  2000,
  4000,
  200,
  # H2
  meanH2
)

# Решение
Res<-lp("min", objective.in, const.mat, const.dir, const.rhs)
# Результат
Res$solution
# 7460.887   335.648    41.435  3749.418 29843.550  1664.352   165.740 13331.264  4476.533   156.033   149.166  7498.836  7460.887   260.055    50.834  5832.428

H1_vec<-function(v) {
  return(sum(v*c(
        1,5.8112,78.2357,0.5357,
        1,5.8112,78.2357,0.5357,
        1,5.8112,78.2357,0.5357,
        1,5.8112,78.2357,0.5357
    )))
}

H2_vec<-function(v) {
  return(sum(v*c(
    0,1.6,1.2,0,
    0,0.4,0.4,0,
    0,0,0.24,0.64,
    0,0,0,0
  )))
}

H1_vec(Res$solution) #111429.5
H2_vec(Res$solution) #6153.85

optimum<-c(
  # поменял порядок, поскольку он именно такой в датасете
  #total_price   #total_speed   #total_hd    #total_ram
  7460.887,      335.648,       3749.418,    41.435,
  29843.550,     1664.352,      13331.264,   165.740,
  4476.533,      156.033,       7498.836,    149.166,
  7460.887,      260.055,       5832.428,    50.834
)

lmPrice <- 1492.1775
# N<-c(ceiling(optimum[1]/lmPrice), ceiling(optimum[5]/lmPrice), ceiling(optimum[9]/lmPrice), ceiling(optimum[13]/lmPrice))
N<-c(     optimum[1]/lmPrice, optimum[5]/lmPrice, optimum[9]/lmPrice,  optimum[13]/lmPrice )
Speed<-c( optimum[2]/N[1],    optimum[6]/N[2],    optimum[10]/N[3],    optimum[14]/N[4] )
Hd<-c(    optimum[3]/N[1],    optimum[7]/N[2],    optimum[11]/N[3],    optimum[15]/N[4] )
Ram<-c(   optimum[4]/N[1],    optimum[8]/N[2],    optimum[12]/N[3],    optimum[16]/N[4] )
# Идеальные точки для каждого из сегментов
ideal_1 = c(Speed[1], Hd[1], Ram[1])
ideal_2 = c(Speed[2], Hd[2], Ram[2])
ideal_3 = c(Speed[3], Hd[3], Ram[3])
ideal_4 = c(Speed[4], Hd[4], Ram[4])

###############################
# Утилиты
###############################

distance<-function(A, B){
  return(sqrt(sum((A-B)^2)))
}

# Приведение конструктивных показатей к однонаправленной шкале [0,100], 
# направление улучшения - возрастание показателя.
NormalizeDataset <- function(dataset) {
  # определение максимального значения из столбца
  # Vmax<-max(frame$field_i); 
  # определение минимального значения из столбца
  # Vmin<-min(frame$field_i);
  # Чем больше значение, тем лучше
  # v <- N * (v - Vmin) / (Vmax - Vmin)
  # Чем меньше значение, тем лучше
  # v <- N * (Vmax - v) / (Vmax - Vmin)
  
  N <- 100
  newDataset <- dataset
  # цена; чем ниже, тем лучше
  maxVal <- max(dataset$price);
  minVal <- min(dataset$price);
  newDataset$price <- N * (maxVal - dataset$price) / (maxVal - minVal)
  # скорость; чем выше, тем лучше
  maxVal <- max(dataset$speed);
  minVal <- min(dataset$speed);
  newDataset$speed <- N * (dataset$speed - minVal) / (maxVal - minVal)
  # объем жесткого диска; чем больше, тем лучше
  maxVal <- max(dataset$hd);
  minVal <- min(dataset$hd);
  newDataset$hd <- N * (dataset$hd - minVal) / (maxVal - minVal)
  # объем оперативной памяти; чем больше, тем лучше
  maxVal <- max(dataset$ram);
  minVal <- min(dataset$ram);
  newDataset$ram <- N * (dataset$ram - minVal) / (maxVal - minVal)
  
  return(newDataset)
}

# Приведение конструктивных показатей к однонаправленной шкале [0,100], 
# направление улучшения - возрастание показателя.
NormalizedIdeal <- function(dataset, ideal) {
  N <- 100
  # скорость; чем выше, тем лучше
  maxVal <- max(dataset$speed);
  minVal <- min(dataset$speed);
  nSpeed <- N * (ideal[1] - minVal) / (maxVal - minVal)
  # объем жесткого диска; чем больше, тем лучше
  maxVal <- max(dataset$hd);
  minVal <- min(dataset$hd);
  nHd <- N * (ideal[2] - minVal) / (maxVal - minVal)
  # объем оперативной памяти; чем больше, тем лучше
  maxVal <- max(dataset$ram);
  minVal <- min(dataset$ram);
  nRam <- N * (ideal[3] - minVal) / (maxVal - minVal)
  return(c(nSpeed, nHd, nRam))
}


# Проверка доминирования по Парето X над Y
DominatesOver<-function(X, Y) {
  # у X есть хотя-бы один параметр, который лучше, чем у Y.
  hasAdvantage <- FALSE;
  # Пришлось закостылить, т.к. учитываем только 2-5 столбцы
  for (i in 2:5) {
    if (X[i] > Y[i]) {
      hasAdvantage <- TRUE
    } else if (X[i] < Y[i]) {
      return(FALSE)
    }
  }
  if (hasAdvantage) {
    return(TRUE)
  }
  return(FALSE)
}

###############################
###############################

# Отобор вариантов, удовлетворяющих условиям работоспособности.
FilteredDataset<-data.frame()
nrow(Dataset)
for (i in c(1:length(rownames(Dataset))))
{
  if (Dataset[i, "screen"] >= 15 & Dataset[i, "multi"] == "yes") {
    FilteredDataset<-rbind(FilteredDataset, Dataset[i,])
  }
}
nrow(FilteredDataset)

# приведение к одной шкале
nDataset <- NormalizeDataset(FilteredDataset)

# определение парето-оптимальных вариантов
pOptVaiantsIDs<-c()
for (i in c(1:length(rownames(nDataset))) ) {
  isParetoOptiomal<-TRUE
  for (j in c(1:length(rownames(nDataset)))) {
    if (DominatesOver(nDataset[j,], nDataset[i,])) {
      isParetoOptiomal<-FALSE # если над i-м вариантом доминирует какой-либо j-й, то i-й точно не оптимален по Парето.
    }
  }
  if (isParetoOptiomal) {
    pOptVaiantsIDs<-c(pOptVaiantsIDs, rownames(nDataset)[i])
  }
}
pOptVaiantsIDs

# выбрать наиболее близкую к идеалу альтернативу
getClosestOption<-function(nIdeal, optVariantsIDs){
  minDist <- .Machine$integer.max
  closestOptionID<-1
  for (i in optVariantsIDs){
    tempDist <- distance(nIdeal, nDataset[i, (3:5)])
    if (tempDist < minDist) {
      minDist <- tempDist
      closestOptionID = i
    }
  }
  return(closestOptionID)
}

# Нормализованные идеальные точки для каждого из сегментов
nIdeal_1 = NormalizedIdeal(Dataset, ideal_1)
nIdeal_2 = NormalizedIdeal(Dataset, ideal_2)
nIdeal_3 = NormalizedIdeal(Dataset, ideal_3)
nIdeal_4 = NormalizedIdeal(Dataset, ideal_4)

# лучшие варианты для каждого из сегментов
closestOptionsIDs <- c(
  getClosestOption(nIdeal_1, pOptVaiantsIDs),
  getClosestOption(nIdeal_2, pOptVaiantsIDs),
  getClosestOption(nIdeal_3, pOptVaiantsIDs),
  getClosestOption(nIdeal_4, pOptVaiantsIDs)
)

pOptVaiantsIDs

# результаты
FilteredDataset[closestOptionsIDs[1], ]
FilteredDataset[closestOptionsIDs[2], ]
FilteredDataset[closestOptionsIDs[3], ]
FilteredDataset[closestOptionsIDs[4], ]

