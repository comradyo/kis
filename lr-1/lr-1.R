# Установка рабочей директории
setwd('~/kis/lr-1')

# Загрузка датасета
Dataset<-read.csv("Computers.csv",sep=",")
head(Dataset)

# Каждый компьютер - это Wi \in W, где W = Dataset - множество решений

# price, speed, hd, ram - основные конструктивные параметры P1, P2, P3, P4.

# best(price) = min(price)
# best(speed, hd, ram) = max(speed, hd, ram)

# Количество станций каждого сегмента для 8 варианта:
# 5   <= C1 <=  9
# 20  <= C2 <=  32
# 3   <= C3 <=  18
# 5   <= C4 <=  14

# Регрессионный анализ — набор статистических методов исследования влияния одной или нескольких независимых
# переменных x1, ..., xn на зависимую переменную y. Независимые переменные иначе называют регрессорами или предикторами, 
# а зависимые переменные — критериальными или регрессантами. 
# Терминология зависимых и независимых переменных отражает лишь математическую зависимость переменных (корелляцию), 
# а не причинно-следственные отношения.

# lm() используется для подбора моделей линейной регрессии.
lin_model <- lm(price~speed+ram+hd, W)
lin_model
# (Intercept)      speed       ram           hd  
#  1492.1775       5.8112      78.2357      -0.5357  
# price ~ 1492.1775 + 5.8112 * speed + 78.2357 * ram - 0.5357 * hd

# Функция predict() используется для прогнозирования значений на основе входных данных.
g <- predict(lin_model, W)
View(data.frame(W$price, g))

###############################
# Построить двухуровневую задачу проектирования КИС. 
# На верхнем уровне оптимизируется стоимость всей системы в целом. 
# На нижнем уровне по сегментам оптимизируется: 
#   - суммарная производительность (speed, ram) всего серверного оборудования,
#   - суммарный объем долговременной и оперативной памяти (hd, ram). 
# При необходимости провести нормализацию конструктивных параметров.
# Остальные критерии оптимизации, коэффициенты важности выбрать самостоятельно.

# На исходном датафрейме выбрать варианты, удовлетворяющие условиям работоспособности,
# на полученном множестве выбрать Парето-оптимальные решения,
# из множества эффективных по Парето решений подобрать варианты,
# которые наиболее близки к решениям задачи оптимизации.

# Сделать окончательные выводы (i = 1..4):
# Сегмент Ci: количество компьютеров: n_ci, номер компьютера: ID_ci

###############################
# На верхнем уровне мы предъявляем требования к целевым свойствам системы 
# (общесистемным параметрам): производительности, надежности и т.д. 
# На нижнем уровне требования предъявляются к конструктивным параметрам.

###############################

# 1. Верхний уровень:
# Самостоятельно сформулировать ограничения (максимальные или минимальные) 
# на общую стоимость развертывания всей технической инфраструктуры КИС,
# возможные ограничения на суммарную стоимость отдельных типов станций (C1, C2, C3, C4), 
# нижние ограничения на частоту процессора для станций, другие приемлемые ограничения.

# критерии уровней - это общие критерии, они характеризуют направленность (минимизация/максимализация)
# частные критерии характеризуют отношение величин к конкретной величине
# критерии могут характеризоваться направленностью или отношением к величине

# Критерий верхнего уровня:
  # H1 = N1 * price1 + ... + N4 * price4 -> min
  # H1 = sum(Ni * (1492.1775 + 5.8112 * speed_i + 78.2357 * ram_i - 0.5357 * hd_i))
  # H1 = 
  # 1492.1775 * N1 + 5.8112 * N1 * speed1 + 78.2357 * N1 * ram1 - 0.5357 * N1 * hd1 +
  # 1492.1775 * N2 + 5.8112 * N2 * speed1 + 78.2357 * N2 * ram1 - 0.5357 * N2 * hd1 +
  # 1492.1775 * N3 + 5.8112 * N3 * speed1 + 78.2357 * N3 * ram1 - 0.5357 * N3 * hd1 +
  # 1492.1775 * N4 + 5.8112 * N4 * speed1 + 78.2357 * N4 * ram1 - 0.5357 * N4 * hd1

# xi1 = 1492.1775 * Ni
# xi2 = speed_i * Ni
# xi3 = ram_i * Ni
# xi4 = hd_i * Ni

# price_i = 1492.1775 + 5.8112 * speed_i + 78.2357 * ram_i - 0.5357 * hd_i
# price_i * Ni = xi1 + 5.8112 * xi2 + 78.2357 * xi3 - 0.5357 * xi4

# Для нахождения ограничений на xi2, xi3, xi4 можно взять усредненные характеристики:
mean(W$speed) # = 52.0110241252596
mean(W$ram)   # = 8.28694679661288
mean(W$hd)    # = 416.601693561272

# Тогда:
  # Ci_min * 1492.1775  <= xi1 <= Ci_max * 1492.1775
  # Ci_min * 52.011     <= xi2 <= Ci_max * 52.011
  # Ci_min * 8.287      <= xi1 <= Ci_max * 8.287
  # Ci_min * 416.602    <= xi1 <= Ci_max * 416.602

# Ограничения нижнего уровня (4 штуки):
  # Cуммарная стоимость компьютеров сегмента C1 должна быть не более 10000 у.е.
    # N1 * price <= 10000
    # x11 + 5.8112 * x12 + 78.2357 * x13 - 0.5357 * x14 <= 10000
  # Cуммарная суммарная производительность C2 не менее 300
    # N2 * speed2 >= 300
    # x22 >= 300
  # Суммарный объем жесткого диска сегментов C3 и C4 не менее 7500
    # N3 * hd3 + N4 * hd4 >= 7500
    # x34 + x44 >= 7500
  # Cуммарный объем оперативно памяти C4 не менее 180
    # N4 * ram4 >= 300
    # x43 >= 180

# Частные критерии оптимизации на нижнем уровне (4 штуки):
  # Cуммарная производительность (speed, ram) в сегменте C1 максимизируется:
    # W1 = 0.7 * N1 * speed1 + 0.3 * N1 * ram1 -> max
    # W1 = 0.7 * x12 + 0.3 * x13 -> max
  # Суммарный объем памяти (ram, hd) в сегменте C3 максимизируется:
    # W2 = 0.3 * N3 * ram3 + 0.8 * N3 * ram3 -> max
    # W2 = 0.3 * x33 + 0.8 * x34 -> max
  # Cуммарная производительность C1 и C2 максимизируется:
    # W3 = 0.9 * N1 * speed1 + 0.9 * N1 * ram1 + 0.4 * N2 * speed2 + 0.4 * N2 * ram2 -> max
    # W3 = 0.9 * x12 + 0.9 * x13 + 0.4 * x22 + 0.4 * x23 -> max

# Критерий нижнего уровня: 
  # H2 = W1 + 0.8 * W2 + W3 -> max
  # H2 = 0.7 * x12 + 0.3 * x13 + 0.8 * (0.3 * x33 + 0.8 * x34) + 0.9 * x12 + 0.9 * x13 + 0.4 * x22 + 0.4 * x23 -> max

# Привести 



Data<-data.frame(
  Dataset$price, Dataset$speed, Dataset$ram, Dataset$hd,
  W1(Dataset$speed, Dataset$ram), W2(Dataset$ram, Dataset$hd), W3(Dataset$speed, Dataset$ram, Dataset$speed, Dataset$ram),
  H1(Dataset$price, )
                 P2, WP4, WP6, W1(WP2), W2(WP4),
                 S(WP2, WP4, WP6),R(WP2, WP4, WP6),  
                 T(WP2, WP4, WP6))
colnames(Data)<-c("P1","P2","P3","P4","P5","P6","W1", "W2", "S", "R", "T")
View(Data)

# p1, .. p6 из 2 примера лекции - это конструктивные параметры. В ЛР - это price, speed, hd, ram
W1 <- function(x12, x13){ return( 0.7 * x12 + 0.3 * x13 ) }
W2 <- function(x23, x24){ return( 0.3 * x23 + 0.8 * x24 ) }
W3 <- function(x12, x13, x22, x23){ return( 0.9 * x12 + 0.9 * x13 + 0.4 * x22 + 0.4 * x23 ) }

H1 <- function(
    x11, x12, x13, x14, 
    x21, x22, x23, x24, 
    x31, x32, x33, x34, 
    x41, x42, x43, x44
) {
  return (
    x11 + 5.8112 * x12 + 78.2357 * x13 - 0.5357 * x14 +
    x21 + 5.8112 * x22 + 78.2357 * x23 - 0.5357 * x24 +
    x31 + 5.8112 * x32 + 78.2357 * x33 - 0.5357 * x34 +
    x41 + 5.8112 * x42 + 78.2357 * x43 - 0.5357 * x44
  )
}

H2 <- function (
    x12, x13, x23, x24, x12, x13, x22, x23
) {
  return (
    0.7 * x12 + 0.3 * x13 + 0.8 * (0.3 * x33 + 0.8 * x34) + 0.9 * x12 + 0.9 * x13 + 0.4 * x22 + 0.4 * x23
  )
}

W2<-function(p3,p4){return(0.08*p3+0.5*p4)}
S<-function(p1,p2,p3,p4,p5,p6){return(0.7*p1+0.3*p2+0.8*p3+0.12*p4+0.15*p5+0.05*p6)}
R<-function(p1,p2,p3,p4,p5,p6){return(0.1*p1+0.3*p2+0.8*p3+0.44*p4+0.32*p5-0.2*p6)}
T<-function(p1,p2,p3,p4,p5,p6){return(0.3*p1-0.003*p2-0.002*p3+0.2*p4-0.32*p5+0.25*p6)}

# Нормализация делается для оптимизации по Парето уже после решения матрицы

# Итого:
# 



# H - это гипер-критерии, то есть, совокупность (сумма) нескольких критериев
# H1 = pr1 * C1 + pr2 * C2 + pr3 * C3 + pr4 * C4 -> min
# W1 = speed1 * C1 * 0.8 + ram1 * C1 * 0.4 -> max
# W3 = hd3 * C3 * 0.5 + ram3 * C3 * 0.8 -> max

###############################

# Утилиты

# Приведение конструктивных показатей к однонаправленной шкале [0,100], 
# направление улучшения - возрастание показателя.
SetScale <- function(frame) {
  # определение максимального значения из столбца
  # Vmax<-max(frame$field_i); 
  # определение минимального значения из столбца
  # Vmin<-min(frame$field_i);
  # Чем больше значение, тем лучше
  # v <- N * (v - Vmin) / (Vmax - Vmin)
  # Чем меньше значение, тем лучше
  # v <- N * (Vmax - v) / (Vmax - Vmin)
  
  N <- 100
  newFrame <- frame
  # цена; чем ниже, тем лучше
  maxVal <- max(frame$price);
  minVal <- min(frame$price);
  newFrame$price <- frame$price * 100000 + N * (maxVal - frame$price) / (maxVal - minVal)
  # скорость; чем выше, тем лучше
  maxVal <- max(frame$speed);
  minVal <- min(frame$speed);
  newFrame$speed <- N * (frame$speed - minVal) / (maxVal - minVal)
  # объем жесткого диска; чем больше, тем лучше
  maxVal <- max(frame$hd);
  minVal <- min(frame$hd);
  newFrame$hd <- N * (frame$hd - minVal) / (maxVal - minVal)
  # объем оперативной памяти; чем больше, тем лучше
  maxVal <- max(frame$ram);
  minVal <- min(frame$ram);
  newFrame$ram <- N * (frame$ram - minVal) / (maxVal - minVal)
  
  return(newFrame)
}

scaledData <- SetScale(W)

# Проверка доминирования по Парето  X над Y
DominatesOver<-function(X, Y) {
  # у X есть хотя-бы один параметр, который лучше, чем у Y.
  hasAdvantage <- FALSE;
  # Пришлось закостылить, т.к. учитываем только 2-5 столбцы
  for (i in 2:5) {
    if (X[i] > Y[i]) {
      hasAdvantage <- TRUE
    } else if (X[i] < Y[i]) {
      return(FALSE)
    }
  }
  if (hasAdvantage) {
    return(TRUE)
  }
    return(FALSE)
}







