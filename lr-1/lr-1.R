# Установка рабочей директории
setwd('~/kis/lr-1')

# Загрузка датасета
Data<-read.csv("Computers.csv",sep=",")
head(Data)

# Data frame - это тип, используемый для отображения данных, по своей сути является таблицей.
# В отличии от матриц, разные столбцы могут иметь разные типы.
# Подробнее: https://r-coder.com/dataframe-r/
Count_low<-data.frame()

# rbind() - встроенная функция, которая объединяет элементы векторов, матриц, фреймов
# Подробнее: https://r-lang.com/rbind-in-r/
Count_low<-rbind(
  # Вариант 8 (из методички):
  Count_low, c(8, 5, 20, 3, 5)
)

colnames(Count_low)<-c("Вариант", "Количество С1 >=", "Количество С2 >=", "Количество С3 >=", "Количество С4 >=") 
head(Count_low)

Count_up<-data.frame()
Count_up<-rbind(
  Count_up, c(8, 9, 32, 18, 14)
)
colnames(Count_up)<-c("Вариант","Количество С1 <=","Количество С2 <=", "Количество С3 <=", "Количество С4 <=") 
head(Count_up)

# Регрессионный анализ — набор статистических методов исследования влияния одной или нескольких независимых
# переменных x1, ..., xn на зависимую переменную y. Независимые переменные иначе называют регрессорами или предикторами, 
# а зависимые переменные — критериальными или регрессантами. 
# Терминология зависимых и независимых переменных отражает лишь математическую зависимость переменных (корелляцию), 
# а не причинно-следственные отношения.

# lm() используется для подбора моделей линейной регрессии.
lin_model <- lm(price~speed+ram+hd, Data)
lin_model
# (Intercept)      speed       ram           hd  
#  1492.1775       5.8112      78.2357      -0.5357  

# Функция predict() используется для прогнозирования значений на основе входных данных.
g <- predict(lin_model, Data)
View(data.frame(Data$price, g))

###############################
# Построить двухуровневую задачу проектирования КИС. 
# На верхнем уровне оптимизируется стоимость всей системы в целом. 
# На нижнем уровне по сегментам оптимизируется: 
#   - суммарная производительность (speed, ram) всего серверного оборудования,
#   - суммарный объем долговременной и оперативной памяти. 
# При необходимости провести нормализацию конструктивных параметров. 
# Остальные критерии оптимизации, коэффициенты важности выбрать самостоятельно.

# На исходном датафрейме выбрать варианты, удовлетворяющие условиям работоспособности, 
# на полученном множестве выбрать Парето-оптимальные решения, 
# из множества эффективных по Парето решений подобрать варианты, 
# которые наиболее близки к решениям задачи оптимизации.

# Сделать окончательные выводы (i = 1..4):
# Сегмент Ci: количество компьютеров: n_ci, номер компьютера: ID_ci

###############################
# На верхнем уровне мы предъявляем требования к целевым свойствам системы 
# (общесистемным параметрам): производительности, надежности и т.д. 
# На нижнем уровне требования предъявляются к конструктивным параметрам.

###############################


# 1. Верхний уровень:
# Самостоятельно сформулировать ограничения (максимальные или минимальные) 
# на общую стоимость развертывания всей технической инфраструктуры КИС,
# возможные ограничения на суммарную стоимость отдельных типов станций (C1, C2, C3, C4), 
# нижние ограничения на частоту процессора для станций, другие приемлемые ограничения.

# критерии уровней - это общие критерии, они характеризуют направленность (минимизация/максимализация)
# частные критерии характеризуют отношение величин к конкретной величине

max_price <- 50000 # максимальная суммарная стоимость станций
# C1 * price1 + C2 * price2 + C3 * price3 + C4 * price4 <= 50000

max_c1_price <- 10000 # максимальные суммарные стоимости станций c_i
# C1 * price1 <= 10000
max_c2_price <- 10000
# C2 * price2 <= 50000
max_c3_price <- 20000
# C3 * price3 <= 20000
max_c4_price <- 20000
# C4 * price4 <= 20000

min_c1_hd <- 50 # минимальный суммарный объем памяти c1, c2
# C1 * hd1 >= 50
min_c2_hd <- 70
# C2 * hd2 >= 70

min_c3_speed <- 2000 # минимальная скорость компьютеров c3, c4
# C3 * speed3 >= 2000
min_c4_speed <- 3000
# C4 * speed4 >= 3000

# H - это гипер-критерии, то есть, совокупность (сумма) нескольких критериев
# H1 = pr1 * C1 + pr2 * C2 + pr3 * C3 + pr4 * C4 -> min
# W1 = speed1 * C1 * 0.8 + ram1 * C1 * 0.4 -> max
# W3 = hd3 * C3 * 0.5 + ram3 * C3 * 0.8 -> max

###############################

# Утилиты

# Приведение конструктивных показатей к однонаправленной шкале [0,100], 
# направление улучшения - возрастание показателя.
SetScale <- function(frame) {
  # определение максимального значения из столбца
  # Vmax<-max(frame$field_i); 
  # определение минимального значения из столбца
  # Vmin<-min(frame$field_i);
  # Чем больше значение, тем лучше
  # v <- N * (v - Vmin) / (Vmax - Vmin)
  # Чем меньше значение, тем лучше
  # v <- N * (Vmax - v) / (Vmax - Vmin)
  
  N <- 100
  newFrame <- frame
  # цена; чем ниже, тем лучше
  maxVal <- max(frame$price);
  minVal <- min(frame$price);
  newFrame$price <- frame$price * 100000 + N * (maxVal - frame$price) / (maxVal - minVal)
  # скорость; чем выше, тем лучше
  maxVal <- max(frame$speed);
  minVal <- min(frame$speed);
  newFrame$speed <- N * (frame$speed - minVal) / (maxVal - minVal)
  # объем жесткого диска; чем больше, тем лучше
  maxVal <- max(frame$hd);
  minVal <- min(frame$hd);
  newFrame$hd <- N * (frame$hd - minVal) / (maxVal - minVal)
  # объем оперативной памяти; чем больше, тем лучше
  maxVal <- max(frame$ram);
  minVal <- min(frame$ram);
  newFrame$ram <- N * (frame$ram - minVal) / (maxVal - minVal)
  
  return(newFrame)
}

scaledData <- SetScale(Data)

# Проверка доминирования X над Y
DominatesOver<-function(X, Y) {
  # у X есть хотя-бы один параметр, который лучше, чем у Y.
  hasAdvantage <- FALSE;
  # Пришлось закостылить, т.к. учитываем только 2-5 столбцы
  for (i in 2:5) {
    if (X[i] > Y[i]) {
      hasAdvantage <- TRUE
    } else if (X[i] < Y[i]) {
      return(FALSE)
    }
  }
  if (hasAdvantage) {
    return(TRUE)
  }
    return(FALSE)
}







